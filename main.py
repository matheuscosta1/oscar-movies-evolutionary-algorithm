# -*- coding: utf-8 -*-
"""Trabalho - CE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dmSJxr06lVQreTmBKTR2FbUM06MHjcLs

# Imports
"""
import random
import time
from functools import reduce
from typing import List

import numpy as np
from tabulate import tabulate

DAY_DELIMITER = -1


class Movie:
    def __init__(self, name: str, rating: float, duration: float, genres: List[str]):
        self.name = name
        self.rating = float(rating)
        self.duration = float(duration)
        self.genres = genres

    def __repr__(self):
        return f'{{{self.name} | {self.rating} | {self.duration}m}}'


Chromosome = List[int]

movies = []
index_precedence = []
with open('movies.csv', 'r') as file:
    movies = list(map(lambda line: Movie(line[0], line[3], line[4], [line[5], line[6]]),
                      list(map(lambda line: line.split(','), file.readlines()[1:]))))


def generate_random_chromosome(data_size: int):
    ns = np.array(list(range(data_size)))  # [1, 2. ..., n]
    chrom = [DAY_DELIMITER] * (2 * data_size - 1)  # 2*n-1 => [-1, -1, -1, -1,....,-1]
    chrom_available_pos = np.array(list(range(2 * data_size - 1)))
    np.random.shuffle(ns)
    np.random.shuffle(chrom_available_pos)
    while len(ns) > 0:
        n = ns[0]
        chrom[chrom_available_pos[0]] = n
        chrom_available_pos = chrom_available_pos[1:]
        ns = ns[1:]
    return chrom


def generate_random_chromosome_with_pattern(data_size: int):
    ns = np.array(list(range(data_size)))
    chrom = [DAY_DELIMITER] * (2 * data_size - 1)
    chrom_available_pos = np.array(list(range(0, 2 * data_size, 2)))
    np.random.shuffle(ns)
    while len(ns) > 0:
        n = ns[0]
        chrom[chrom_available_pos[0]] = n
        chrom_available_pos = chrom_available_pos[1:]
        ns = ns[1:]
    return chrom


def create_initial_population(data_size, generator, pop_size=100):
    return list(map(lambda a: generator(data_size), range(pop_size)))


def inversion_mutation(chromosome: Chromosome, rate=0.001):
    chrom_len = len(chromosome)
    randoms = np.random.rand(chrom_len)
    for i in range(chrom_len):
        p = randoms[i]
        if p > (1.0 - rate):
            p1, p2 = random.randint(0, chrom_len - 1), random.randint(0, chrom_len - 1)
            aux = chromosome[p1]
            chromosome[p1] = chromosome[p2]
            chromosome[p2] = aux
    return chromosome


def displacement_mutation(chromosome: Chromosome, rate=0.002):
    chrom_len = len(chromosome)
    if random.random() > (1.0 - rate):
        cuts = np.random.randint(0, chrom_len, size=2)
        cuts[1] = cuts[0] + 1
        cuts = np.sort(cuts)
        cutted = chromosome[cuts[0]:cuts[1]]
        one = np.concatenate((chromosome[0:cuts[0]], chromosome[cuts[1]:]), axis=None)
        insert_point = np.random.randint(0, len(one), size=1)[0]
        chromosome = np.concatenate((one[0:insert_point], cutted, one[insert_point:]), axis=None)
        chromosome = np.int8(chromosome)
    return chromosome


def treat_chromosome(chrom):
    init = False
    groups = []
    current_group = []
    for gene in chrom:
        if gene == DAY_DELIMITER:
            if len(current_group) > 0:
                groups.append(current_group)
            current_group = []
        else:
            current_group.append(gene)

    if len(current_group) > 0:
        groups.append(current_group)
    return groups


def eval(chrom: Chromosome) -> float:
    e = -1
    movies_per_days = treat_chromosome(chrom)
    per_day_sum = [reduce(lambda x, x1: (x[0] * (movies[x1].rating), movies[x1].duration + x[1]), day, (1, 0)) for day
                   in movies_per_days]  # retorna [(1*Rating*Rating, Duração + Duraçao) dos filmes do dia]
    all_day_less_240 = all([x[1] <= 240 for x in per_day_sum])

    return sum([x[0] for x in per_day_sum]) if all_day_less_240 else -1


def eval_population(pop: List[Chromosome]):
    evals = []
    max_ = [0, 0]
    worst1 = [0, 10000000000]
    worst2 = [0, 10000000000]
    for i in range(len(pop)):
        e = eval(pop[i])
        if e > max_[1]:
            max_ = [i, e]
        if e < worst1[1]:
            worst1 = [i, e]
        elif e < worst2[1]:
            worst2 = [i, e]
        evals.append(e)
    return evals, max_[0], worst1[0], worst2[0]


def get_pair_pointcuts(high: int):
    while True:
        pc1 = np.random.randint(low=1, high=high, dtype=int)
        pc2 = np.random.randint(low=1, high=high, dtype=int)
        if pc1 != pc2: break

    if pc2 > pc1:
        return pc1, pc2
    else:
        return pc2, pc1


def ox1(first: np.array, second: np.array):
    size = len(first)
    off1 = np.full(size, -1)
    off2 = np.full(size, -1)
    pc1, pc2 = get_pair_pointcuts(size)
    fillOff1 = {}
    fillOff2 = {}

    i = pc1
    j = 0
    p1 = first[pc1:pc2]
    p2 = second[pc1:pc2]
    while i < pc2:
        a = p1[j]
        b = p2[j]
        off1[i] = a
        fillOff1[a] = True
        off2[i] = b
        fillOff2[b] = True
        i = i + 1
        j = j + 1

    i = pc2
    j = pc2
    k = pc2
    while i < size:
        a = second[i]
        b = first[i]

        if a not in fillOff1:
            off1[j] = a
            j = j + 1

        if b not in fillOff2:
            off2[k] = b
            k = k + 1
        i = i + 1

    i = 0
    while i < pc2:
        if j == size: j = 0
        if k == size: k = 0
        a = second[i]
        b = first[i]

        if a not in fillOff1:
            off1[j] = a
            j = j + 1
        if b not in fillOff2:
            off2[k] = b
            k = k + 1
        i = i + 1

    return off1, off2


def single_point_crossover(parents: List[Chromosome]):
    cut_point = random.randint(0, len(pop[0]))
    return np.array(parents[0][0:cut_point] + parents[1][cut_point:], parents[1][0:cut_point] + parents[0][cut_point:])


def ox1_crossover(parents: List[Chromosome]) -> List[Chromosome]:
    first_parent, second_parent = parents[0], parents[1]
    off1, off2 = ox1(first_parent, second_parent)
    return np.array([off1, off2])


def cross_over(pop: List[Chromosome], evals, max_: float, cross_function=single_point_crossover, show_evals=False):
    parents_count = 2
    pop_size = len(pop)
    probs = [abs(e / max_) for e in evals]

    parent_positions = np.random.choice(pop_size, parents_count, probs)
    parents = [pop[parent] for parent in parent_positions]
    if show_evals:
        print(f"Eval Parents:{[evals[i] for i in parent_positions]}")

    offsprings = []

    while len(offsprings) < 2:
        offspring1, offspring2 = cross_function(parents)
        if eval(offspring1) >= 0:
            offsprings.append(offspring1)

        if eval(offspring2) >= 0:
            offsprings.append(offspring2)

    if show_evals:
        print("Offspring Eval: ", eval(offsprings[0]), eval(offsprings[1]))
    return offsprings[0], offsprings[1]


def replace_invalid(pop: List[Chromosome]):
    evals, _, _, _ = eval_population(pop)
    invalid_indexes = list(map(lambda a: a[0], list(filter(lambda a: a[1] == -1, list(enumerate(evals))))))
    while len(invalid_indexes) > 0:
        off_inc = 0
        offs = []
        while off_inc < len(invalid_indexes):
            off1, off2 = cross_over(pop, evals, best_eval, ox1_crossover, show_evals=True)
            offs.append(off1)
            offs.append(off2)
            off_inc += 2

        for i in invalid_indexes:
            pop[i] = offs[off_inc - 1]
            off_inc -= 1
        evals, _, _, _ = eval_population(pop)
        invalid_indexes = list(map(lambda a: a[0], list(filter(lambda a: a[1] == -1, list(enumerate(evals))))))


execution_number = 30

if __name__ == '__main__':
    times = []
    best_chromossome = []
    number_of_days = []
    for j in range(execution_number):

        start_time = time.time()

        MAX_EPOCHS = 10000  # 10000  # @param {type: "number"}
        POP_SIZE = 100  # @param {type: "number"}
        epoch = 0
        n_bests = [[-1, -1]]

        pop = create_initial_population(len(movies), generate_random_chromosome_with_pattern, pop_size=POP_SIZE)

        last_better = 0

        while epoch < MAX_EPOCHS or last_better < 100:
            # Evaluate
            evals, best, worst1, worst2 = eval_population(pop)

            best_eval = evals[best]
            best_chrom = pop[best]

            # Is someone better ?
            if best_eval > n_bests[-1][0]:
                # print(best_eval, n_bests[-1][0])
                n_bests.append([best_eval, np.array(best_chrom)])
                last_better += 0

            # Generate the children
            off1, off2 = cross_over(pop, evals, best_eval, ox1_crossover)
            pop[worst1] = off1
            pop[worst2] = off2

            # Replace Invalid Configurations
            replace_invalid(pop)

            # Apply Mutation
            for i in range(len(pop)):
                pop[i] = displacement_mutation(pop[i], 0.001)

            epoch += 1

            last_better += 1

        groups = treat_chromosome(n_bests[-1][1])

        days = []
        for i in range(len(groups)):
            movies_name, each_duration, sum_duration, rating, sum_rate = [], [], 0, [], 0
            for index in groups[i]:
                movies_name.append(movies[index].name)
                each_duration.append(str(movies[index].duration))
                sum_duration += movies[index].duration
                rating.append(str(movies[index].rating))
                sum_rate += movies[index].rating
            days.append(
                [i + 1, ', '.join(movies_name), ', '.join(each_duration), sum_duration, ', '.join(rating), sum_rate])

        days = sorted(days, key=lambda a: a[-1], reverse=True)

        iteration_time = time.time() - start_time
        times.append(iteration_time)
        best_chromossome.append(n_bests[-1][0])
        number_of_days.append(len(groups))

    print(tabulate(days, headers=['Dia', "Filmes", 'Duração', 'Duração Acumulada', 'Rating', 'Rating Acumulado'],
                   tablefmt="fancy_grid"))

    data = [[
        'Métrica',
        'Mínimo',
        'Média',
        'Máximo',
        'Desvio Padrão'
    ],
        [
            "Tempo(s)",
            round(min(times), 2),
            round(np.average(times), 2),
            round(max(times), 2),
            round(np.std(times), 3)],
        [
            "Rating",
            round(min(best_chromossome), 2),
            round(np.average(best_chromossome), 2),
            round(max(best_chromossome), 2),
            round(np.std(best_chromossome), 2)
        ],
        [
            "Dias", min(number_of_days),
            np.average(number_of_days),
            max(number_of_days),
            round(np.std(number_of_days), 2)
        ]]
    print(tabulate(data, tablefmt="fancy_grid"))
